SiDaTa plan!

* Overview
Access to Excel and CSV files through a consistent and
easy-to-understand interface (notably, one like mzReport, but a bit better.)

May add table-like access to sqlite as well.

Dict-style indexing into tables by row and/or column, which return
dict-like objects with each cell indexed by column or row (as
appropriate.)

Some other utilities that have been found helpful (e.g.,
collectByCriterion, although with a better name.)

Python 2 and 3 compatible!

* Main access scheme

** "Static" Tables
Tables are objects which represent the read-in data from a table
object; these allow indexing by column (if desired, and intelligible
column headers are found) or row (if desired, and intelligble row
headers are found.)

Absent corresponding headers, rows and columns are numbered.

These can also be constructed by appending rows and/or columns, and
saved back to disk.  There's a subtlety there- added rows being
consistent with columns, added columns being consistent with rows;
allow only new columns that specify values for each present row, and
vice versa (although perhaps allow all-empty rows/cols by default.)

Tables are iterable, giving all the rows; also have .Rows and .Columns
iterators, which iterate over rows and columns respectively.  (Perhaps
also .EnumRows and .EnumColumns, which also return row/col number with
each.)

Functionality to delete rows or columns.

CollectByCriterion-like functions; .GroupRows and .GroupColumns, which
given a string or lambda collect rows/cols by matching header value or
lambda evaluation value. (Alternately, .RowsByValue and
.ColumnsByValue?)

Filter functions; .FilterRows and .FilterColumns that take a lambda
expression on rows/cols and return a new table with all rows/cols the
lambda evaluates to something truthy.

** Readers/Writers
ReaderTables are generators that represent iteratively-read-in data
from a table; return series of rows.  (Essentially, mzReport reader
objects.)  WriterTables, likewise, let one write a table by row;
essentially mzReport writer objects.)

No column version of the same, for obvious disk-related reasons.
** Row and Column Objects
Both are subclasses of dict which have as their keys the column (for
rows) or row (for columns) headers and as their values the
corresponding cells.

For row/col objects obtained from Tables, altering cells alters the cell
in the Table itself.
* Other details/features

Conversion from matrixes and pandas dataframes
* Implementation strategy

For each file format, figure out a mzReport-style reader iterator.
This becomes the basis for TableReader and also the load-in process
for creating a Table.

Tables represent their data as a list of lists (list of rows), with
column and row header dicts (mapping header string to index.)
-------This is not ideal!  Because it makes adding a new column
potentially linear time with respect to the total number of cells
in the table.

Row/col objects inherit the corresponding row list, or constructed
column list, and the appropriate header dict; indexing into the row/col
is done by two stage lookup; list[dict[string]].

* Hard Design Descisions / Potential gotchas

If column headers are not explicitly specified, should
automatically??? get headers from first row of table, but this could
hide the first row if it's data rather than headers!  (Or just warn about
it and don't change things?)

Row headers, if given as a list, must start at the first /real/ row,
skipping the header row, if any.